#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netdb.h>
#include <stdbool.h>

#define BACKLOG 5
#define MSG_SIZE 256

/* Error handler to display given user information and message generated by compiler based on errno */
void error(const char* error_msg)
{
    perror(error_msg);
    exit(1);
}

/* Instruction parser returns result if valid Instruction else returns -404*/
float decrypt(char message[])
{
    int i=0,op_1,op_2;
    char op_code[4];
    char opnd_1[4];
    char opnd_2[4];

    for(i=0;i<9;i++)
    {
        if(i<3)
        {
            op_code[i]=message[i];
        }
        else if(i>=3&&i<6)
        {
            if (message[i] == ' ') {
                i = 6;
                continue;
            }
            opnd_1[i-3]=message[i];
        }
        else
        {
            opnd_2[i-6]=message[i];
        }
    }
    op_code[3]='\0';
    opnd_1[3]='\0';
    opnd_2[3]='\0';
    op_1=atoi(opnd_1);
    op_2=atoi(opnd_2);
    if(!strcmp(op_code,"MUL"))
    {
        return(op_1*op_2);
    }
    else if(!strcmp(op_code,"DIV"))
    {
        return(op_1/op_2);
    }
    else if(!strcmp(op_code,"ADD"))
    {
        return(op_1+op_2);
    }
    else if(!strcmp(op_code,"SUB"))
    {
        return(op_1-op_2);
    }
    else
    {
        return -404;
    }
}



int main(int argc, char* argv[])
{
    int sockfd, new_fd , portno, output;
    socklen_t client_length;
    char* buffer = (char*)malloc(MSG_SIZE* sizeof(char));
    struct sockaddr_in serv_addr,client_addr;
    pid_t childpid;

    if( argc < 2 ) {
        fprintf(stderr, " usage %s portno\n", argv[0]);
        exit(0);
    }

    /*Create a socket with IPv4 and TCP protocols*/
    sockfd = socket(AF_INET, SOCK_STREAM, 0);

    if( sockfd < 0 ) {
        error("ERROR opening socket");
    }

    /*Clear and set server address with corresponding values*/
    memset(&serv_addr , 0 , sizeof(serv_addr));
    portno = atoi(argv[1]);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);

    /*Bind the socket with the server address*/
    if(bind(sockfd, (struct sockaddr* ) &serv_addr, sizeof(serv_addr)) < 0) {
        error("ERROR on binding");
    }

    /*Listen for requests*/
    listen(sockfd,BACKLOG);
    client_length = sizeof(client_addr);

    while (true) {

        /*Accept a connection from queue*/
        new_fd = accept(sockfd, (struct sockaddr *) &client_addr, &client_length);

        if (new_fd < 0) {
            error("ERROR on accept");
        }

        /*fork() system call to handle multiple clients*/
        if((childpid = fork()) == 0) {

            close(sockfd);

            while (true) {

                /*Read and write messages from and to the client*/
                memset(buffer, 0 , MSG_SIZE);
                if( read(new_fd, buffer , MSG_SIZE) < 0) {
                    error("ERROR reading from the socket");
                }
                printf("Client : %s", buffer);
                output = decrypt(buffer);
                if(output == -404) {
                    memset(buffer,0,MSG_SIZE);
                    fgets(buffer,MSG_SIZE-1,stdin);
                }
                else {
                    buffer = gcvt(output, 10 , buffer);
                }
                if( write(new_fd,buffer,strlen(buffer)) < 0) {
                    error("ERROR writing to the socket");
                }

            }

        }


    }

    close(new_fd);
    close(sockfd);
    return 0;

}
